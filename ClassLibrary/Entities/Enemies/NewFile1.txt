// public class Node {
        //     public int X;
        //     public int Y;
        //
        //     public int Cost = 1;
        //
        //     // public int Heuristic;
        //     public int Depth;
        //     public Node Parent;
        //
        //     public int SetParent(Node parent) {
        //         Depth = parent.Depth + 1;
        //         Parent = parent;
        //         return Depth;
        //     }
        //     public Node(int x, int y) {
        //         X = x;
        //         Y = y;
        //     }
        // }
        //
        // private Node[,] nodes;
        //
        // public class Step {
        //     public int X;
        //     public int Y;
        //     public Step(int x, int y) {
        //         X = x;
        //         Y = y;
        //     }
        // }
        //
        // public class Path {
        //     public List<Step> Steps = new List<Step>();
        // }
        //
        // static List<Node> closed = new List<Node>();
        // static List<Node> open = new List<Node>();
        //
        // private Path PathFinder(int selfX, int selfY, int targetX, int targetY, Level level) {
        //     try {
        //         // if (level[targetX, targetY].CanMove == false) {
        //         //     return null;
        //         // }
        //
        //         nodes = new Node[level.Width, level.Height];
        //         for (int i = 0; i < level.Width; i++) {
        //             for (int j = 0; j < level.Height; j++) {
        //                 nodes[i, j] = new Node(i, j);
        //             }
        //         }
        //
        //         closed.Clear();
        //         open.Clear();
        //         nodes[selfX, selfY].Cost = 0;
        //         nodes[selfX, selfY].Depth = 0;
        //         open.Add(nodes[selfX, selfY]);
        //         nodes[targetX, targetY].Parent = null;
        //
        //         int counter = 1;
        //
        //         int maxSearchDistance = 1000;
        //         int maxDepth = 0;
        //         while (open.Count > 0 && maxDepth < maxSearchDistance) {
        //             Node current = open.First();
        //             if (current == nodes[targetX, targetY]) {
        //                 break;
        //             }
        //             open.Remove(current);
        //             closed.Add(current);
        //
        //             for (int x = -1; x < 2; x++) {
        //                 for (int y = -1; y < 2; y++) {
        //                     if ((x == 0) && (y == 0)) continue;
        //                     if ((x != 0) && (y != 0)) continue;
        //
        //                     int posX = x + current.X;
        //                     int posY = y + current.Y;
        //                     if (isValid(level, selfX, selfY, x, y)) {
        //                         int nextStepCost = current.Cost + 1;
        //                         Node nextNode = nodes[posX, posY];
        //                         //map.pathFinderVisited(xp, yp);
        //
        //                         if (nextStepCost < nextNode.Cost) {
        //                             if (open.Contains(nextNode)) {
        //                                 open.Remove(nextNode);
        //                             }
        //                             if (closed.Contains(nextNode)) {
        //                                 closed.Remove(nextNode);
        //                             }
        //                         }
        //                         if (!open.Contains(nextNode) && !closed.Contains(nextNode)) {
        //                             nextNode.Cost = nextStepCost;
        //                             // nextNode.Heuristic = GetHeuristic(posX, posY, targetX, targetY);
        //
        //                             maxDepth = Math.Max(maxDepth, nextNode.SetParent(current));
        //                             open.Add(nextNode);
        //                         }
        //                     }
        //                 }
        //             }
        //         }
        //         if (nodes[targetX, targetY].Parent == null) {
        //             return null;
        //         }
        //         Path path = new Path();
        //         Node target = nodes[targetX, targetY];
        //         while (target != nodes[selfX, selfY]) {
        //             path.Steps.Add(new Step(target.X, target.Y));
        //             target = target.Parent;
        //         }
        //         path.Steps.Add(new Step(selfX, selfY));
        //         return path;
        //     }
        //
        //     catch (Exception e) {
        //         Console.WriteLine(e);
        //         throw;
        //     }
        // }
        //
        // private bool isValid(Level level, int selfX, int selfY, int x, int y) {
        //     if (x < 0 || y < 0 || x >= level.Width || y >= level.Height) return false;
        //     if (selfX == x || selfY == y) return false;
        //     return level[x, y].CanMove;
        // }

        // private int GetHeuristic(int currentX, int currentY, int targetX, int targetY) {
        //     var dx = Math.Abs(targetX - currentX);
        //     var dy = Math.Abs(targetY - currentY);
        //     return dx + dy;
        // }